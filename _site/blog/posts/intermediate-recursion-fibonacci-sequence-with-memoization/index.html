<!DOCTYPE html>
<html>
  <head>
    <title>Peter Debelak | Intermediate Recursion - Fibonacci Sequence with Memoization</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
    <link rel="stylesheet" href="/css/main.css">
  </head>
  <body >
    <div class="wrapper">
      <header class="container-fluid">
        <h1><a href="/">Peter Debelak</a></h1>
      </header>

      <div class="container" >
        <nav class="col-md-3 col-md-push-9 col-sm-4 col-sm-push-8 navbar navbar-default" role="navigation">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#sidebar">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <p class="navbar-text visible-xs-block">Menu </p>
          </div>
          <div class="collapse navbar-collapse" id="sidebar">
            <ul class="nav nav-pills nav-stacked">
              <li class=""><a href="/resume/">Resume</a></li>
              <li class=""><a href="/about/">About</a></li>
              <li class="active"><a href="/blog/posts">Blog</a></li>
              <li><a href="https://github.com/pdebelak">Peter on Github</a></li>
            </ul>
          </div>
        </nav>

        <div class="col-md-9 col-md-pull-3 col-sm-8 col-sm-pull-4" id="main-content">
          <h1>Intermediate Recursion - Fibonacci Sequence with Memoization</h1>
<p>After <a href="http://www.peterdebelak.com/blog/posts/recursion-basics-adding-numbers-in-an-array-with-javascript">my last post</a> where I described some recursion basics with JavaScript, I thought it would be fun to get into a slightly more advanced topic: <a href="http://en.wikipedia.org/wiki/Memoization">Memoization</a>.</p>

<p>You can read that article, but the basic concept of memoization is not repeating calculations if you've already found the answer. The example used there is finding factorials (<code>5! = 5 * 4 * 3 * 2 * 1</code>), but that only works if you call the function multiple times in your program. I want to talk about those rare cases where memoization comes in handy within the function itself.</p>
<p class="lead">Fibonacci Sequence</p>
<p>You've probably heard about this sequence before - it's the one followed by pine cones and the golden ratio. It starts <code>0, 1, 1, 2, 3, 5, 8, 13...</code> where each number is the sum of the two previous numbers.</p>
<p>Based on that description, you can probably guess if we wanted to calculate the <code>nth</code> fibonacci number, recursion would come in handy. The first pass looks like this in JavaScript:</p>
<pre>
function fibonacci(positiveInteger) {
    if (positiveInteger === 1) {
        return 1;
    } else if (positiveInteger === 0) {
        return 0;
    } else {
        return fibonacci(positiveInteger - 2) + fibonacci(positiveInteger - 1);
    }
}
</pre>
<p>Makes sense? You build in some automatic returns for <code>0</code> and <code>1</code> and then it works as expected with the answer being the sum of the two previous fibonacci numbers.</p>
<p class="lead">The problem</p>
<p>It works great! The problem, though, lies in trying to calculate larger numbers. Running <a href="http://nodejs.org/">node</a> in the terminal on my Chromebook starts getting slow around <code>fibonacci(30)</code> and <code>fibonacci(100)</code> appears to completely crash my terminal. I suspect it would stop running at some point, but I don't want to wait all day.</p>
<p class="lead">The solution - Memoization</p>
<p>As you probably guessed, we can use memoization to improve this behavior. How? Each time we calculate a fibonacci number using the above function, we were calculating all the fibonacci numbers down to <code>0</code>. This involves a <em>lot</em> of repeated calculations. Let's try to remember all the fibonacci numbers we've calculated and pass them into the recursive calls.</p>
<pre>
function fibonacci(positiveInteger, foundFibonaccis) {
    if (typeof(foundFibonaccis) === 'undefined') {
        var found = { 0: 0, 1: 1 };
    } else {
        var found = foundFibonaccis;
    }
    if (typeof(found[positiveInteger]) !== 'undefined') {
        return found[positiveInteger];
    } else {
        found[positiveInteger] = fibonacci(positiveInteger - 2, found) + fibonacci(positiveInteger - 1, found);
    }
    return found[positiveInteger];
}
</pre>
<p>Now we are storing each calculated number in an object and passing it into future recursive calls. If nothing is passed in, I set the object to <code>{ 0: 0, 1: 1 }</code> much like I supplied the answers for <code>0</code> and <code>1</code> in the first function.</p>
<p>Does that improve the performance? Oh yeah! On my Chromebook I now get the answer for <code>fibonacci(1000)</code> almost instantly. In fact, I get the answer up to <code>fibonacci(1476)</code> right away and the only reason I can't calculate higher fibonacci numbers is that JavaScript can't handle it and starts returning <code>Infinity</code>.</p>
<p>I hope you found this mini introduction to memoization helpful. If you've found other areas where memoization would be helpful sound off in the comments!</p>


        </div>
      </div>
      <div class="push"></div>
    </div>
    <footer class="container-fluid">
      <h4 class="text-right">
        <a href="mailto:pdebelak@gmail.com">Contact Peter</a>
      </h4>
    </footer>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
  </body>
</html>
